\section{Serial IO Module}

The serial IO module is designed to provide a simple mechanism for writing
information from selected buses and/or branches to standard output or a file
using a consistent ordering scheme. Individual buses and/or branches implement a
write method that will write bus/branch information to a single string. This
information usually consists of bus or branch identifiers plus some parameters
that are desired in the output. The serial IO module then gathers this
information, moves it to the head node, and writes it out in a consistent order.
An example of this type of output is shown in Figure~\ref{fig:serial_out}.

\begin{figure}
  \centering
    \includegraphics*[width=0.5in, height=0.5in, keepaspectratio=true]{figures/20pix-white-square}

{
\color{red}
\bfseries
\begin{Verbatim}[commandchars=\\\{\}]
   Bus Voltages and Phase Angles

   Bus Number      Phase Angle      Voltage Magnitude

          1          0.000000             1.060000
          2         -4.982589             1.045000
          3        -12.725100             1.010000
          4        -10.312901             1.017671
          5         -8.773854             1.019514
          6        -14.220946             1.070000
          7        -13.359627             1.061520
          8        -13.359627             1.090000
          9        -14.938521             1.055932
         10        -15.097288             1.050985
         11        -14.790622             1.056907
         12        -15.075585             1.055189
         13        -15.156276             1.050382
         14        -16.033645             1.035530
\end{Verbatim}
}
  \caption{Example output from buses in a 14 bus problem.}
  \label{fig:serial_out}
\end{figure}

Note that the output is ordered by bus index (which matches the ordering of the buses in the original network configuration file). This ordering would be preserved regardless of the number of processors used in the calculation.

Like the mapper, the serial IO classes are relatively easy to use. Most of the complexity is associated with implementing the \texttt{\textbf{serialWrite}} methods in the buses and branches. Data can be written out for buses and/or branches using either the \texttt{\textbf{SerialBusIO}} class or the \texttt{\textbf{SerialBranchIO}} class. These are again templated classes that take the network as an argument in the constructor. Both classes reside in the \texttt{\textbf{gridpack::serial\_io}} namespace. The \texttt{\textbf{SerialBusIO}} constructor has the form

{
\color{red}
\begin{Verbatim}[fontseries=b]
SerialBusIO<MyNetwork>(int max_str_len,
   boost::shared_ptr<MyNetwork> network)
\end{Verbatim}
}

The variable \texttt{\textbf{max\_str\_len}} is the length, in bytes, of the maximum size string you would want to write out using this class and \texttt{\textbf{network}} is a pointer to the network that is used to generate output. The value of max\_str\_len is used to allocate internal memory and also determines how much data needs to be moved around each time data from the entire network is written out. As the value of this parameter increases, the amount of memory needed and the amount of data that needs to move increases, so this value should be kept to a minimum, if possible. 

Two additional functions can be used to actually generate output. They are

{
\color{red}
\begin{Verbatim}[fontseries=b]
void header(const char *string) const
\end{Verbatim}
}

and 

{
\color{red}
\begin{Verbatim}[fontseries=b]
void write(const char *signal = NULL)
\end{Verbatim}
}

The \texttt{\textbf{header}} method is a convenience function that will only write the buffer string from the head processor (process 0) and can be used for creating the headings above an output listing. The \texttt{\textbf{write}} function traverses all the buses in the network and writes out the strings generated by the \texttt{\textbf{serialWrite}} methods in the buses. The \texttt{\textbf{SerialBusIO}} object is responsible for reordering these strings in a consistent manner, even if the buses are distributed over many processors. The optional variable ``\texttt{\textbf{signal}}'' is passed to the \texttt{\textbf{serialWrite}} methods and can be used to control what output is listed. For example, in one part of a simulation it might be desirable to list the voltage magnitude and phase angle from a powerflow calculation and in another part of the calculation to list the rotor angle for a generator. These two outputs could be distinguished from each other in the \texttt{\textbf{serialWrite}} function using the \texttt{\textbf{signal}} variable.

To generate the output in Figure~\ref{fig:serial_out}, the following calls are used

{
\color{red}
\begin{Verbatim}[fontseries=b]
gridpack::serial_io::SerialBusIO<MyNetwork> busIO(128,network);
busIO.header("\n   Bus Voltages and Phase Angles\n");
busIO.header(
  "\n   Bus Number      Phase Angle      Voltage Magnitude\n");
busIO.write();
\end{Verbatim}
}

The first call creates the \texttt{\textbf{SerialIOBus}} object and specifies the internal buffers size (128 bytes). This buffer must be large enough to incorporate the output from any call to one of the \texttt{\textbf{serialWrite}} calls in the bus components. The next two lines print out the header on top of the bus listing and the last line generates the listing itself. The \texttt{\textbf{serialWrite}} implementation looks like

{
\color{red}
\begin{Verbatim}[fontseries=b]
bool gridpack::myapp::MyBus::serialWrite(char *string,
       const int bufsize, const char *signal)
{  
  double pi = 4.0*atan(1.0);
  double angle = p_a*180.0/pi;
  sprintf(string, "     %6d      %12.6f         %12.6f\n",
          getOriginalIndex(),angle,p_v);
  return true;
}
\end{Verbatim}
}

For this simple case, \texttt{\textbf{signal}} is ignored as well as the variable
\texttt{\textbf{bufsize}}. The return value of the function is set to
\texttt{\textbf{true}}. If more than one type of bus listing was desired,
additional conditions based on the value of \texttt{\textbf{signal}} could be
included. For the case of generators, the length of the output may vary from one
bus to the next since buses can have different numbers of generators associated
with them. It may therefore be important to check the length of the output
string being generated against the size of the buffer to make sure there is no
overwrite and to take some kind of appropriate action if there is. Output from
generators is also conditional on the bus having some generators. In this case,
the return value, \texttt{\textbf{true}} or \texttt{\textbf{false}} can be used
to signal whether of not the bus is returning some data.

If you wish to direct the output to a file, then calling the function

{
\color{red}
\begin{Verbatim}[fontseries=b]
void open(const char *filename)
\end{Verbatim}
}

will direct all output from the serial IO object to the file specified in the variable filename. Similarly, calling the function

{
\color{red}
\begin{Verbatim}[fontseries=b]
void close(void)
\end{Verbatim}
}

will close the file and all subsequent writes are directed back to standard output. The same \texttt{\textbf{SerialBusIO}} object can be used to write data to multiple different files, as long as the files are opened and closed sequentially. If two files need to be used at the same time, then two \texttt{\textbf{SerialBusIO}} objects need to be created. Two additional methods can be used to further control where output goes. If a file already exists, you can use the function

{
\color{red}
\begin{Verbatim}[fontseries=b]
boost::shared_ptr<std::ofstream> getStream()
\end{Verbatim}
}

to recover a pointer to the file stream currently being used by the \texttt{\textbf{SerialBusIO}} object. This can then be used to redirect output from some other part of the code to the same file. The function

{
\color{red}
\begin{Verbatim}[fontseries=b]
void setStream(boost::shared_ptr<std::ofstream> stream)
\end{Verbatim}
}

can be used to redirect the output from the \texttt{\textbf{SerialIOBus}} object to an already existing file. The main use of these two functions is to direct the output from both buses and branches to the same file instead of standard output.
The \texttt{\textbf{SerialBranchIO}} module is similar to the \texttt{\textbf{SerialBusIO}} module but works by creating listings for branches. The constructor is

{
\color{red}
\begin{Verbatim}[fontseries=b]
SerialBranchIO<MyNetwork>(int max_str_len,
   boost::shared_ptr<MyNetwork> network)
\end{Verbatim}
}

and the header and write methods are

{
\color{red}
\begin{Verbatim}[fontseries=b]
void header(const char *string) const

void write(const char *signal = NULL)
\end{Verbatim}
}

These have exactly the same behavior as in the \texttt{\textbf{SerialBusIO}} class. Similarly, the methods

{
\color{red}
\begin{Verbatim}[fontseries=b]
void open(const char *filename)

void close(void)

boost::shared_ptr<std::ofstream> getStream()

void setStream(boost::shared_ptr<std::ofstream> stream)
\end{Verbatim}
}

can be used to redirect output to a file instead of standard output.

The usual method for directing the output from both a SerialBusIO object and SerialBranchIO object to the same file is to use the calling sequence

{
\color{red}
\begin{Verbatim}[fontseries=b]
SerialBusIO<MyNetwork> busIO(max_str_len, network);
SerialBranchIO<MyNetwork> branchIO(max_str_len, network);
busIO.open("file.dat");
branchIO.setStream(busIO.getStream());
\end{Verbatim}
}

The file can be closed by calling close from either \texttt{\textbf{busIO}} or \texttt{\textbf{branchIO}}.
In some cases it may be useful to use the serial IO module to extract information from the network to a data structure that can then be used in some other analysis. This can be done in the case of the contingency analysis to get a list of properties for all buses or branches in the system that can then be used as input to some other module. Instead of writing the strings to a file, the output can be sent to a vector of strings instead, where each string in the vector represents the output from a single bus or branch. The individual strings in the vector can then be parsed to extract properties of individual buses or branches. For both the \texttt{\textbf{SerialBusIO}} class and \texttt{\textbf{SerialBranchIO}} classes, the method is

{
\color{red}
\begin{Verbatim}[fontseries=b]
std::vector<std::string> writeStrings(const char *signal = NULL)
\end{Verbatim}
}

If the output describes the properties of something like generators or
individual transmission lines, each string may describe multiple devices. Note
that this vector is only produced on one processor (corresponding to rank 0 on
whatever communicator the network is using). Other processors will have a zero
length vector. The contents of each string can then be parsed to extract other
parameters (see section of String Utilities for some useful tools for doing
this). The powerflow output described above can be parsed to get the voltage
magnitude and phase angle on each bus. This information can then be stored in a
vector that can be saved to the \texttt{\textbf{GlobalStore}} or
\texttt{\textbf{StatBlock}} data structures described described in sections
\ref{global_store} and \ref{analysis}.
