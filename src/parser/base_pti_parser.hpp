/*
 *     Copyright (c) 2013 Battelle Memorial Institute
 *     Licensed under modified BSD License. A copy of this license can be found
 *     in the LICENSE file in the top level directory of this distribution.
 */
/*
 *  Created on: December 30, 2014
 *      Author: Kevin Glass, Bruce Palmer
 *
 *  Added SEXS exciter model: Nov 7, 2022
 *      Author: Shrirang Abhyankar
 * 
 *  Renamed REGCA1/regca1 parameters to regc
 *  Added REGCB1
 *  Added REGCC1
 */

#ifndef BASEPTIPARSER_HPP_
#define BASEPTIPARSER_HPP_

#define OLD_MAP

#include <iostream>
#include <string>
#include <vector>
#include <map>
#ifndef OLD_MAP
#include <boost/unordered_map.hpp>
#endif


#include "gridpack/component/base_component.hpp"
#include "gridpack/timer/coarse_timer.hpp"
#include "gridpack/component/data_collection.hpp"
#include "gridpack/parser/dictionary.hpp"
#include "gridpack/utilities/exception.hpp"
#include "gridpack/utilities/string_utils.hpp"
#include "gridpack/network/base_network.hpp"
#include "gridpack/parser/base_parser.hpp"
#include "gridpack/parser/hash_distr.hpp"
#include "gridpack/factory/base_factory.hpp"
#include "parser_classes/gencls.hpp"
#include "parser_classes/gensal.hpp"
#include "parser_classes/genrou.hpp"
#include "parser_classes/plbi.hpp"
#include "parser_classes/gdform.hpp"
#include "parser_classes/regca1.hpp"
#include "parser_classes/regcb1.hpp"
#include "parser_classes/regcc1.hpp"
#include "parser_classes/reeca1.hpp"
#include "parser_classes/repca1.hpp"
#include "parser_classes/wsieg1.hpp"
#include "parser_classes/exdc1.hpp"
#include "parser_classes/ieeet1.hpp"
#include "parser_classes/esst1a.hpp"
#include "parser_classes/esst4b.hpp"
#include "parser_classes/ggov1.hpp"
#include "parser_classes/tgov1.hpp"
#include "parser_classes/wshygp.hpp"
#include "parser_classes/lvshbl.hpp"
#include "parser_classes/frqtpat.hpp"
#include "parser_classes/distr1.hpp"
#include "parser_classes/cim6bl.hpp"
#include "parser_classes/acmtblu1.hpp"
#include "parser_classes/ieelbl.hpp"
#include "parser_classes/cmldblu1.hpp"
#include "parser_classes/psssim.hpp"
#include "parser_classes/sexs.hpp"
#include "parser_classes/gast.hpp"
#include "parser_classes/hygov.hpp"
#include "parser_classes/wtdta1.hpp"
#include "parser_classes/wtara1.hpp"
#include "parser_classes/wtpta1.hpp"
#include "parser_classes/wttqa1.hpp"

namespace gridpack {
namespace parser {

template <class _network>
class BasePTIParser : public BaseParser<_network>
{
  public:

    /**
     * Constructor
     */
    explicit BasePTIParser()
    {
      p_timer = gridpack::utility::CoarseTimer::instance();
    }


    /**
     * Destructor
     */
    virtual ~BasePTIParser(){}

    /**
     * Parse a second file after original network has been distributed. This
     * requires the data in the second file to be distributed to all network
     * objects that need the data
     * @param fileName name of file
     */
    void externalParse(const std::string &fileName)
    {
      std::string ext = getExtension(fileName);
      if (ext == "dyr") {
        getDSExternal(fileName);
        expandBusModels();
      } else if (ext == "uc") {
        getUCExternal(fileName);
      }
    }

    /**
     * Split PSS/E formatted lines into individual tokens using both blanks and
     * commas as delimiters
     * @param line input string from PSS/E file
     * @return vector of tokens parsed from PSS/E line
     */
    std::vector<std::string> splitPSSELine (std::string line)
    {
      std::vector<std::string> ret;
      int i, j;
      std::vector<std::string>  split_line;
      // split line into tokens based on comma delimiters
      boost::algorithm::split(split_line, line, boost::algorithm::is_any_of(","),
                    boost::token_compress_off);
      int slen = split_line.size();
      // parse each token based on blank spaces
      for (i=0; i<slen; i++) {
        if (isBlank(split_line[i])) {
          // If two consecutive commas have nothing in between, replace it with
          // a zero "0" character. This should be converted to 0 and 0.0 by the
          // atoi and atof functions, respectively
          ret.push_back("0");
        } else {
          std::vector<std::string> tokens;
          tokens = p_util.blankTokenizer(split_line[i]);
          int tlen = tokens.size();
          for (j=0; j<tlen; j++) ret.push_back(tokens[j]);
        }
      }
      return ret;
    }

    /**
     * Expand any compound bus models that may need to be generated based on
     * parameters in the .dyr files. This function needs to be called after
     * calling the parser for the .dyr file
     */
    void expandBusModels(void)
    {
      // Find maximum original bus index. This value can be used to assign
      // indices to new buses generated by expanding the model
      int max_idx = -1;
      int nbus = p_network->numBuses();
      int totalBuses = p_network->totalBuses();
      int totalBranches = p_network->totalBranches();
      int i, j;
      for (i=0; i<nbus; i++) {
        if (p_network->getActiveBus(i)) {
          if (max_idx < p_network->getOriginalBusIndex(i)) {
            max_idx = p_network->getOriginalBusIndex(i);
          }
        }
      }
      p_network->communicator().max(&max_idx,1);

      // Create new data collection objects corresponding to new buses and
      // branches for the expanded composite load
      std::vector<std::vector<gridpack::component::DataCollection*> >
        new_buses;
      std::vector<std::vector<gridpack::component::DataCollection*> >
        new_branches;
      gridpack::component::DataCollection *data;
      std::string model;
      int nload;
      std::vector<int> comp_buses;
      for (i=0; i<nbus; i++) {
        // Only expand bus on process that owns bus. New buses and branches will
        // not have connections to other processors
        if (p_network->getActiveBus(i)) {
         data = p_network->getBusData(i).get();
         if (data->getValue(LOAD_NUMBER,&nload)) {
           for (j=0; j<nload; j++) {
             if (data->getValue(LOAD_MODEL,&model, j)) {
               if (model == "CMLDBLU1") {
                 std::vector<gridpack::component::DataCollection*> buses;
                 std::vector<gridpack::component::DataCollection*> branches;
                 Cmldblu1Parser<load_params> parser;
                 parser.expandModel(data, buses, branches, j);
                 new_buses.push_back(buses);
                 new_branches.push_back(branches);
                 comp_buses.push_back(i);
               }
             }
           }
         }
        }
      }
      // Check to see if there actually are any buses to expand. If not, quit
      // now.
      int ncomp = comp_buses.size();
      p_network->communicator().sum(&ncomp,1);
      if (ncomp == 0) return;

      // Find new indices for the buses. Start by finding out how many new buses
      // have been added to the system
      int nprocs = p_network->communicator().size();
      int me = p_network->communicator().rank();
      std::vector<int> added_buses(nprocs);
      for (i=0; i<nprocs; i++) {
        added_buses[i] = 0;
      }
      int numLoads = new_buses.size();
      // Subtract 1 because bus 0 corresponds to the original bus and
      // already has an index
      for (i=0; i<numLoads; i++) {
        added_buses[me] += new_buses[i].size()-1;
      }
      p_network->communicator().sum(&added_buses[0],nprocs);
      std::vector<int> offset(nprocs);
      offset[0] = 0;
      for (i=1; i<nprocs; i++) {
        offset[i] = offset[i-1] + added_buses[i-1];
      }
      // Assign new original indices to the new buses
      int icnt = 0;
      int idx;
      std::vector<std::vector<int> > local_bus;
      for (i=0; i<numLoads; i++) {
        std::vector<int> lidx;
        lidx.push_back(comp_buses[i]);
        for (j=1; j<new_buses[i].size(); j++) {
          data = (new_buses[i])[j];
          idx = offset[me]+icnt+max_idx+1;
          data->addValue(BUS_NUMBER, idx);
          p_network->addBus(idx);
          *(p_network->getBusData(nbus+icnt))
            = *data;
          p_network->setActiveBus(nbus+icnt,true);
          lidx.push_back(nbus+icnt);
          icnt++;
        }
        local_bus.push_back(lidx);
      }
      // New buses now have original IDs and are complete.
      // Now need to set "from" and "to"
      // indices for new branches as well as fixing up neighor lists
      int from, to, i1, i2;
      icnt = 0;
      int nbranch = p_network->numBranches();
      for (i=0; i<numLoads; i++) {
        for (j=0; j<new_branches[i].size(); j++) {
          // Assign new bus IDs to new branches
          data = (new_branches[i])[j];
          data->getValue(BRANCH_FROMBUS,&from);
          data->getValue(BRANCH_TOBUS,&to);
          (new_buses[i])[from]->getValue(BUS_NUMBER, &i1);
          (new_buses[i])[to]->getValue(BUS_NUMBER, &i2);
          data->setValue(BRANCH_FROMBUS,i1);
          data->setValue(BRANCH_TOBUS,i2);
          p_network->addBranch(i1,i2);
          *(p_network->getBranchData(nbranch+icnt))
            = *data;
          p_network->setActiveBranch(nbranch+icnt,true);
          // Modify neighbor lists etc to account for new buses
          p_network->setLocalBusIndex1(nbranch+icnt,(local_bus[i])[from]);
          p_network->setLocalBusIndex2(nbranch+icnt,(local_bus[i])[to]);
          p_network->addBranchNeighbor((local_bus[i])[from],nbranch+icnt);
          p_network->addBranchNeighbor((local_bus[i])[to],nbranch+icnt);
          icnt++;
        }
      }
      // Completely reset global indices
      p_network->resetGlobalIndices(true);
#if 0
      // Assign global indices to new buses.
      icnt = 0;
      int lcnt = 0;
      // loop over original buses
      for (i=0; i<nbus; i++) {
        if (p_network->getActiveBus(i)) {
          if (i == comp_buses[icnt]) {
            // if original bus is composite bus, loop over new buses;
            for (j=1; j<local_bus[icnt].size(); j++) {
              p_network->setGlobalBusIndex((local_bus[icnt])[j],
                  totalBuses+offset[me]+lcnt);
              lcnt++;
            }
            icnt++;
          }
        }
      }

      // Add global indices to new local branches.
      int nbranch_new = p_network->numBranches();
      std::vector<int> branch_buf(nprocs);
      for (i=0; i<nprocs; i++) {
        branch_buf[i] = 0;
      }
      branch_buf[me] = nbranch_new-nbranch;
      p_network->communicator().sum(&branch_buf[0],nprocs);
      offset[0] = 0;
      for (i=1; i<nprocs; i++) {
        offset[i] = offset[i-1]+branch_buf[i-1];
      }
      icnt = offset[me];
      for (i=nbranch; i<nbranch_new; i++) {
        if (p_network->getActiveBranch(i)) {
          p_network->setGlobalBranchIndex(i,totalBranches+icnt);
          icnt++;
        }
      }

      // Reset remaining indices
      p_network->resetGlobalIndices(false);
#endif
      gridpack::factory::BaseFactory<_network> factory(p_network);
      factory.setComponents();
    }

    /**
     * Change the sign of the BRANCH_SHIFT variable. The sign convention
     * for this variable is not consistent across different files
     */
    void changePhaseShiftSign()
    {
      int i, j, nelems;
      double rval;
      boost::shared_ptr<gridpack::component::DataCollection> data;
      int nbranch = p_network->numBranches();
      for (i=0; i<nbranch; i++) {
        data = p_network->getBranchData(i);
        data->getValue(BRANCH_NUM_ELEMENTS,&nelems);
        for (j=0; j<nelems; j++) {
          if (data->getValue(BRANCH_SHIFT,&rval,j)) {
            rval *= -1.0;
            data->setValue(BRANCH_SHIFT,rval,j);
          }
        }
      }
    }

  protected:

    /* ************************************************************************
     **************************************************************************
     ***** PROTECTED SCOPE
     **************************************************************************
     *********************************************************************** */

    /**
     * Assign network to internal network pointer variable
     */
    void setNetwork(boost::shared_ptr<_network> network)
    {
      p_network = network;
      p_network_data = network->getNetworkData();
      BaseParser<_network>::setNetwork(network);
    }

    /**
     * This routine opens up a .dyr file with parameters for dynamic
     * simulation. It assumes that a .raw file has already been parsed
     */
    void getDS(const std::string & fileName)
    {
      int t_ds = p_timer->createCategory("Parser:getDS");
      p_timer->start(t_ds);
      int me(p_network->communicator().rank());

      if (me == 0) {
        std::ifstream input;
        input.open(fileName.c_str());
        if (!input.is_open()) {
          p_timer->stop(t_ds);
          return;
        }
        find_ds_par(input);
        input.close();
      }
      p_timer->stop(t_ds);
#if 0
      int i;
      printf("BUS data size: %d\n",p_busData.size());
      for (i=0; i<p_network->numBuses(); i++) {
        printf("Dumping bus: %d\n",i);
        p_network->getBusData(i)->dump();
      }
#endif
    }

    // Data structure to hold generator params
    struct gen_params{
      // Generator parameters
      int bus_id; // ID of bus that owns device
      char model[8];  // Model represented by data
      char gen_id[3]; // Generator ID
      double inertia;  // Inertia constant 0
      double damping;  // Damping coefficient
      double reactance; // Transient reactance
      double tdop;
      double tdopp;
      double tqop;
      double tqopp;
      double gn_xd;
      double gn_xq;
      double xdp;
      double xqp;
      double xdpp;
      double gn_xl;
      double gn_s1;
      double s12;
      double vset;
      double mq;
      double kpv;
      double kiv;
      double mp;
      double kppmax;
      double kipmax;
      double emax;
      double emin;
      double tpf;
      double imax;
      double qmax;
      double qmin;
      double kpqmax;
      double kiqmax;
      double tqf;
      double tvf;
      int    vflag;
      char   playback_file[512];
      double playback_iscale;
	  
      int regc_lvplsw;
      double regc_tg;
      double regc_rrpwr;
      double regc_brkpt;
      double regc_zerox;
      double regc_lvpl1;
      double regc_volim;
      double regc_lvpnt1;
      double regc_lvpnt0;
      double regc_lolim;
      double regc_tfltr;
      double regc_khv;
      double regc_iqrmax;
      double regc_iqrmin;
      double regc_accel;
      int    regc_rateflag;
      int    regc_pqflag;
      double regc_te;
      double regc_imax;
      double regc_kip;
      double regc_kii;
      double regc_kppll;
      double regc_kipll;
      double regc_wmax;
      double regc_wmin;
	  
      // Exciter parameters
      bool has_exciter;
      double ex_tr;
      double ex_k;
      double ex_ka;
      double ex_ta_over_tb;
      double ex_ta;
      double ex_tb;
      double ex_tc;
      double ex_emin;
      double ex_emax;
      double vrmax;
      double vrmin;
      double ex_ke;
      double ex_te;
      double ex_kf;
      double tf1;
      double rswitch;
      double ex_e1;
      double se1;
      double ex_e2;
      double se2;
      double uel;
      double vos;
      double vimax;
      double vimin;
      double tc1;
      double tb1;
      double vamax;
      double vamin;
      double ex_kc;
      double ex_tf;
      double klr;
      double ilr;
      double kpr;
      double kir;
      double kpm;
      double kim;
      double vmmax;
      double vmmin;
      double ex_kg;
      double ex_kp;
      double ex_ki;
      double vbmax;
      double ex_xl;
      double thetap;
	  
      int reeca1_ireg;
      int reeca1_pfflag;
      int reeca1_vflag;
      int reeca1_qflag;
      int reeca1_pflag;
      int reeca1_pqflag;
	  
      double reeca1_vdip;
      double reeca1_vup;
      double reeca1_trv;
      double reeca1_dbd1;
      double reeca1_dbd2;
      double reeca1_kqv;
      double reeca1_lqh1;
      double reeca1_lql1;
      double reeca1_vref0;
      double reeca1_lqfrz;
      double reeca1_thld;
      double reeca1_thld2;
      double reeca1_tp;
      double reeca1_qmax;
      double reeca1_qmin;
      double reeca1_vmax;
      double reeca1_vmin;
      double reeca1_kqp;
      double reeca1_kqi;
      double reeca1_kvp;
      double reeca1_kvi;
      double reeca1_vbias;
      double reeca1_tiq;
      double reeca1_dpmax;
      double reeca1_dpmin;
      double reeca1_pmax;
      double reeca1_pmin;
      double reeca1_imax;
      double reeca1_tpord;
      double reeca1_vq1;
      double reeca1_iq1;
      double reeca1_vq2;
      double reeca1_iq2;
      double reeca1_vq3;
      double reeca1_iq3;
      double reeca1_vq4;
      double reeca1_iq4;
      double reeca1_vp1;
      double reeca1_ip1;
      double reeca1_vp2;
      double reeca1_ip2;
      double reeca1_vp3;
      double reeca1_ip3;
      double reeca1_vp4;
      double reeca1_ip4;
	  
      // Governor parameters
      bool has_governor;
      int jbus;
      int gv_m;
      double gv_k;
      double gv_kt;
      double gv_at;
      double gv_t1;
      double gv_t2;
      double gv_t3;
      double gv_uo;
      double gv_uc;
      double pmax;
      double pmin;
      double gv_t4;
      double gv_k1;
      double gv_k2;
      double gv_t5;
      double gv_k3;
      double gv_k4;
      double gv_t6;
      double gv_k5;
      double gv_k6;
      double gv_t7;
      double gv_k7;
      double gv_k8;
      double db1;
      double err;
      double db2;
      double gv1;
      double pgv1;
      double gv2;
      double pgv2;
      double gv3;
      double pgv3;
      double gv4;
      double pgv4;
      double gv5;
      double pgv5;
      int iblock;
      double rselect;
      double flagswitch;
      double gv_r;
      double gv_r2;
      double gv_tr;
      double gv_tf;
      double gv_tg;
      double gv_velm;
      double gv_gmax;
      double gv_gmin;
      double gv_tw;
      double gv_qnl;
      double tpelec;
      double maxerr;
      double minerr;
      double kpgov;
      double kigov;
      double kdgov;
      double tdgov;
      double vmax;
      double vmin;
      double tact;
      double kturb;
      double wfnl;
      double gv_tb;
      double gv_tc;
      double teng;
      double tfload;
      double kpload;
      double kiload;
      double ldref;
      double gv_dm;
      double gv_dt;
      double ropen;
      double rclose;
      double kimw;
      double aset;
      double gv_ka;
      double gv_ta;
      double trate;
      double gv_db;
      double tsa;
      double tsb;
      double rup;
      double rdown;
      double gv_td;
      double gv_ki;
      double gv_kd;
      double gv_kp;
      double gv_tt;
      double gv_kg;
      double gv_tp;
      double velopen;
      double velclose;
      double aturb;
      double bturb;
      double tturb;
      // PSSSIM parameters
      int psssim_inputtype;
      int psssim_bus1;
      int psssim_bus2;
      int psssim_bus3;
      int psssim_bus4;
      int psssim_bus5;
      int psssim_bus6;
      double psssim_gaink;
      double psssim_tw;
      double psssim_t1;
      double psssim_t2;
      double psssim_t3;
      double psssim_t4;
      double psssim_maxout;
      double psssim_minout;

      // plant controller parameters
      int repca1_ireg;
      int repca1_brh_bus_from;
      int repca1_brh_bus_to;
      char repca1_brh_ckt[3];
      int repca1_vcflag;
      int repca1_refflag;
      int repca1_fflag;

      double repca1_tfltr;
      double repca1_kp;
      double repca1_ki;
      double repca1_tft;
      double repca1_tfv;
      double repca1_vfrz;
      double repca1_rc;
      double repca1_xc;
      double repca1_kc;
      double repca1_emax;
      double repca1_emin;
      double repca1_dbd1;
      double repca1_dbd2;
      double repca1_qmax;
      double repca1_qmin;
      double repca1_kpg;
      double repca1_kig;
      double repca1_tp;
      double repca1_fdbd1;
      double repca1_fdbd2;
      double repca1_femax;
      double repca1_femin;
      double repca1_pmax;
      double repca1_pmin;
      double repca1_tg;
      double repca1_ddn;
      double repca1_dup;  

      // Wind model params
      double wind_ka;
      double wind_theta;
      double wind_h;
      double wind_damp;
      double wind_hfrac;
      double wind_freq1;
      double wind_dshaft;
      double wind_kiw;
      double wind_kpw;
      double wind_kic;
      double wind_kpc;
      double wind_kcc;
      double wind_tp;
      double wind_thetamax;
      double wind_thetamin;
      double wind_rthetamax;
      double wind_rthetamin;
      double wind_kpp;
      double wind_kip;
      double wind_twref;
      double wind_temax;
      double wind_temin;
      double wind_p1;
      double wind_spd1;
      double wind_p2;
      double wind_spd2;
      double wind_p3;
      double wind_spd3;
      double wind_p4;
      double wind_spd4;
      double wind_trate;

      int wind_tflag;

    };

    // Data structure to hold relay parameters on buses
    struct bus_relay_params{
      int bus_id; // ID of bus that owns device
      char model[8];  // Model represented by data
      char tag[3]; //
      int jbus;
      int mins;
      int frebus;
      double v1;
      double t1;
      double f1;
      double v2;
      double t2;
      double f2;
      double v3;
      double t3;
      double f3;
      double tb;
      double fl;
      double fu;
      double tp;
    };

    // Data structure to hold relay parameters on branches
    struct branch_relay_params{
      int from_bus; // ID of from bus
      int to_bus; // ID of to bus
      char model[8];  // Model represented by data
      char id[3];
      char id1[3];
      char id2[3];
      char id3[3];
      int ibus;
      int jbus;
      int ibus1;
      int jbus1;
      int ibus2;
      int jbus2;
      int ibus3;
      int jbus3;
      int rs;
      int mtype;
      int bmon;
      int bltype1;
      int bltype2;
      double zone1_time;
      double zone1_reach;
      double zone1_cenang;
      double zone1_cendis;
      double zone2_time;
      double zone2_reach;
      double zone2_cenang;
      double zone2_cendis;
      double zone3_time;
      double zone3_reach;
      double zone3_cenang;
      double zone3_cendis;
      double dirang;
      double thcur;
      double sebtime;
      double serctime;
      double trbtime;
      double trrctime;
      double blint1;
      double blro1;
      double blint2;
      double blro2;
    };

    // Data structure to hold parameters for conventional loads
    struct load_params{
      int bus_id; // ID of bus that owns load
      char model[9];  // Model represented by data
      char id[3]; // Load ID
      int it;
      double ra;
      double xa;
      double xm;
      double r1;
      double x1;
      double r2;
      double x2;
      double e1;
      double se1;
      double e2;
      double se2;
      double mbase;
      double pmult;
      double h;
      double vi;
      double ti;
      double tb;
      double a;
      double b;
      double d;
      double e;
      double c0;
      double tnom;
      double dynload_perc;

      double tstall;
      double trestart;
      double tv;
      double tf;
      double complf;
      double comppf;
      double vstall;
      double rstall;
      double xstall;
      double lfadj;
      double kp1;
      double np1;
      double kq1;
      double nq1;
      double kp2;
      double np2;
      double kq2;
      double nq2;
      double vbrk;
      double frst;
      double vrst;
      double cmpkpf;
      double cmpkqf;
      double vc1off;
      double vc2off;
      double vc1on;
      double vc2on;
      double tth;
      double th1t;
      double th2t;
      double fuvr;
      double uvtr1;
      double ttr1;
      double uvtr2;
      double ttr2;
      double load_ac_perc;

      double a1;
      double a2;
      double a3;
      double a4;
      double a5;
      double a6;
      double a7;
      double a8;
      double n1;
      double n2;
      double n3;
      double n4;
      double n5;
      double n6;

      double mva;
      double bss;
      double rfdr;
      double xfdr;
      double fb;
      double xxf;
      double tfixhs;
      double tfixls;
      double ltc;
      double tmin;
      double tmax;
      double step;
      double vmin;
      double vmax;
      double tdel;
      double ttap;
      double rcomp;
      double xcomp;
      double fma;
      double fmb;
      double fmc;
      double fmd;
      double fel;
      double pfel;
      double vd1;
      double vd2;
      double pfs;
      double p1e;
      double p1c;
      double p2e;
      double p2c;
      double pfreq;
      double q1e;
      double q1c;
      double q2e;
      double q2c;
      double qfreq;

      int mtpa;
      double lfma;
      double rsa;
      double lsa;
      double lpa;
      double lppa;
      double tpoa;
      double tppoa;
      double ha;
      double etrqa;
      double vtr1a;
      double ttr1a;
      double ftr1a;
      double vrc1a;
      double trc1a;
      double vtr2a;
      double ttr2a;
      double ftr2a;
      double vrc2a;
      double trc2a;

      int mtpb;
      double lfmb;
      double rsb;
      double lsb;
      double lpb;
      double lppb;
      double tpob;
      double tppob;
      double hb;
      double etrqb;
      double vtr1b;
      double ttr1b;
      double ftr1b;
      double vrc1b;
      double trc1b;
      double vtr2b;
      double ttr2b;
      double ftr2b;
      double vrc2b;
      double trc2b;

      int mtpc;
      double lfmc;
      double rsc;
      double lsc;
      double lpc;
      double lppc;
      double tpoc;
      double tppoc;
      double hc;
      double etrqc;
      double vtr1c;
      double ttr1c;
      double ftr1c;
      double vrc1c;
      double trc1c;
      double vtr2c;
      double ttr2c;
      double ftr2c;
      double vrc2c;
      double trc2c;

      int mtpd;
      double lfmd;
      double trst;
      double vtr1;
      double vtr2;
    };

    /**
     * This routine opens up a .dyr file with parameters for dynamic
     * simulation and distributes the parameters to whatever processor holds the
     * corresponding buses. It assumes that a .raw file has already been parsed
     */
    void getDSExternal(const std::string & fileName)
    {

      //      int t_ds = p_timer->createCategory("Parser:getDS");
      //      p_timer->start(t_ds);
      int me(p_network->communicator().rank());

      std::vector<gen_params> gen_data;
      std::vector<bus_relay_params> bus_relay_data;
      std::vector<branch_relay_params> branch_relay_data;
      std::vector<load_params> load_data;
      if (me == 0) {
        std::ifstream            input;
        input.open(fileName.c_str());
        if (!input.is_open()) {
          // p_timer->stop(t_ds);
          return;
        }
        find_ds_vector(input, &gen_data, &bus_relay_data,
            &branch_relay_data, &load_data);
        input.close();
      }
      int nsize = gen_data.size();
      std::vector<int> buses;
      int i;
      for (i=0; i<nsize; i++) {
        buses.push_back(gen_data[i].bus_id);
      }
      gridpack::hash_distr::HashDistribution<_network,gen_params,gen_params>
        distr(p_network);
      distr.distributeBusValues(buses,gen_data);
      // Now match data with corresponding data collection objects
      gridpack::component::DataCollection *data;
      nsize = buses.size();
      for (i=0; i<nsize; i++) {
        int l_idx = buses[i];
        data = dynamic_cast<gridpack::component::DataCollection*>
          (p_network->getBusData(l_idx).get());

        // Find out how many generators are already on bus
        int ngen = 0;
        data->getValue(GENERATOR_NUMBER, &ngen);
        // Identify index of generator to which this data applies
        int g_id = -1;
        if (ngen > 0) {
          // Clean up 2 character tag for generator ID
          std::string tag = gen_data[i].gen_id;
          int j;
          for (j=0; j<ngen; j++) {
            std::string t_id;
            data->getValue(GENERATOR_ID,&t_id,j);
            if (tag == t_id) {
              g_id = j;
              break;
            }
          }
        }

        // Check to see parameters can be assigned to a generator
        if (g_id > -1) {
          if (!strcmp(gen_data[i].model,"GENCLS")) {
            GenclsParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"GENSAL")) {
            GensalParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"GENROU")) {
            GenrouParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"GDFORM")) {
            GdformParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"PLBI")) {
            PlbiParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"REGCA1")) {
            Regca1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"REGCB1")) {
            Regcb1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"REGCC1")) {
            Regcc1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"REECA1")) {
            Reeca1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"REPCA1")) {
            Repca1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"REPCTA1")) {
            Repca1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"WSIEG1")) {
            Wsieg1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"EXDC1") ||
              !strcmp(gen_data[i].model,"EXDC2")) {
            Exdc1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"IEEET1")) {
            Ieeet1Parser<gen_params> parser;
	    parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"ESST1A")) {
            Esst1aParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"ESST4B")) {
            Esst4bParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"SEXS")) {
            SexsParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"GGOV1")) {
            Ggov1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"TGOV1")) {
            Tgov1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"GAST")) {
            GastParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
	  } else if (!strcmp(gen_data[i].model,"HYGOV")) {
            HygovParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"WSHYGP")) {
            WshygpParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"PSSSIM")) {
            PsssimParser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"WTDTA1")) {
            Wtdta1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"WTARA1")) {
            Wtara1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"WTPTA1")) {
            Wtpta1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          } else if (!strcmp(gen_data[i].model,"WTTQA1")) {
            Wttqa1Parser<gen_params> parser;
            parser.extract(gen_data[i], data, g_id);
          }
        }
      }
      // Add parameters for a bus relay
      nsize = bus_relay_data.size();
      buses.clear();
      for (i=0; i<nsize; i++) {
        buses.push_back(bus_relay_data[i].bus_id);
      }
      gridpack::hash_distr::HashDistribution<_network,bus_relay_params,
        bus_relay_params> distr_bus(p_network);
      distr_bus.distributeBusValues(buses,bus_relay_data);
      // Now match data with corresponding data collection objects
      nsize = buses.size();
      for (i=0; i<nsize; i++) {
        int l_idx = buses[i];
        data = dynamic_cast<gridpack::component::DataCollection*>
          (p_network->getBusData(l_idx).get());
        // Add relay data to bus
        if (!strcmp(bus_relay_data[i].model,"LVSHBL")) {
          LvshblParser<bus_relay_params> parser;
          parser.extract(bus_relay_data[i], data);
        } else if (!strcmp(bus_relay_data[i].model,"FRQTPAT")) {
          FrqtpatParser<bus_relay_params> parser;
          parser.extract(bus_relay_data[i], data);
        }
      }
      buses.clear();
      // Add parameters for a branch relay
      nsize = branch_relay_data.size();
      std::vector<std::pair<int,int> > branches;
      std::vector<int> lbranch;
      for (i=0; i<nsize; i++) {
        branches.push_back(std::pair<int,int>(branch_relay_data[i].from_bus,
              branch_relay_data[i].to_bus));
      }
      gridpack::hash_distr::HashDistribution<_network,branch_relay_params,
        branch_relay_params> distr_branch(p_network);
      distr_branch.distributeBranchValues(branches,lbranch,branch_relay_data);
      // Now match data with corresponding data collection objects
      nsize = lbranch.size();
      for (i=0; i<nsize; i++) {
        int l_idx = lbranch[i];
        data = dynamic_cast<gridpack::component::DataCollection*>
          (p_network->getBranchData(l_idx).get());
        // Add relay data to branch
        if (!strcmp(branch_relay_data[i].model,"DISTR1")) {
          Distr1Parser<branch_relay_params> parser;
          parser.extract(branch_relay_data[i], data);
        }
      }

      // Add parameters for a load
      nsize = load_data.size();
      buses.clear();
      for (i=0; i<nsize; i++) {
        buses.push_back(load_data[i].bus_id);
      }
      gridpack::hash_distr::HashDistribution<_network,load_params,
        load_params> distr_load(p_network);
      distr_load.distributeBusValues(buses,load_data);
      // Now match data with corresponding data collection objects
      nsize = buses.size();
      for (i=0; i<nsize; i++) {
        int l_idx = buses[i];
        data = dynamic_cast<gridpack::component::DataCollection*>
          (p_network->getBusData(l_idx).get());

        // Find out how many loads are already on bus
        int nload = 0;
        data->getValue(LOAD_NUMBER, &nload);
        // Identify index of load to which this data applies
        int l_id = -1;
        if (nload > 0) {
          // Clean up 2 character tag for generator ID
          std::string tag = load_data[i].id;
          int j;
          for (j=0; j<nload; j++) {
            std::string t_id;
            data->getValue(LOAD_ID,&t_id,j);
            if (tag == t_id) {
              l_id = j;
              break;
            }
          }
        }

        // Assign parameters to a load
        if (l_id > -1) {
          if (!strcmp(load_data[i].model,"CIM6BL")) {
            Cim6blParser<load_params> parser;
            parser.extract(load_data[i], data, l_id);
          } else if (!strcmp(load_data[i].model,"IEELBL")) {
            IeelblParser<load_params> parser;
            parser.extract(load_data[i], data, l_id);
          } else if (!strcmp(load_data[i].model,"ACMTBLU1")) {
            Acmtblu1Parser<load_params> parser;
            parser.extract(load_data[i], data, l_id);
          } else if (!strcmp(load_data[i].model,"CMLDBLU1")) {
            Cmldblu1Parser<load_params> parser;
            parser.extract(load_data[i], data, l_id);
          }
        } else {
          printf("No match found for load on bus %d with tag %s\n",
              load_data[i].bus_id,load_data[i].id);
        }
      }
    }

    struct uc_params{
      int bus_id; // ID of bus that owns generator
      char gen_id[3]; // Generator ID
      int type;
      double init_level; // Initial production level
      double min_gen; // Minimum generation
      double max_gen; // Maximum generation
      double max_oper; // Maximum operating generation
      double min_up;
      double min_down;
      double ramp_up;
      double ramp_down;
      double start_up; // Start up cost
      double const_cost; // Constant cost
      double lin_cost; // Linear cost
      double co_2_cost;
      double init_prd; // Init periods
      double start_cap; // Startup cap
      double shut_cap; // Shutdown cap
    };

    /**
     * This routine opens up a .uc file with parameters for a unit commitment
     * calculationand distributes the parameters to whatever processor holds the
     * corresponding buses. It assumes that a .raw file has already been parsed
     */
    void getUCExternal(const std::string & fileName)
    {

      int me(p_network->communicator().rank());

      std::vector<uc_params> uc_data;
      if (me == 0) {
        std::ifstream            input;
        input.open(fileName.c_str());
        if (!input.is_open()) {
          return;
        }
        find_uc_vector(input, &uc_data);
        input.close();
      }
      int nsize = uc_data.size();
      std::vector<int> buses;
      int i;
      for (i=0; i<nsize; i++) {
        buses.push_back(uc_data[i].bus_id);
      }
      gridpack::hash_distr::HashDistribution<_network,uc_params,uc_params>
        distr(p_network);
      distr.distributeBusValues(buses,uc_data);
      // Now match data with corresponding data collection objects
      gridpack::component::DataCollection *data;
      nsize = buses.size();
      for (i=0; i<nsize; i++) {
        int l_idx = buses[i];
        data = dynamic_cast<gridpack::component::DataCollection*>
          (p_network->getBusData(l_idx).get());

        // Find out how many generators are already on bus
        int ngen;
        if (!data->getValue(GENERATOR_NUMBER, &ngen)) continue;
        // Identify index of generator to which this data applies
        int g_id = -1;
        // Clean up 2 character tag for generator ID
        std::string tag = uc_data[i].gen_id;
        int j;
        for (j=0; j<ngen; j++) {
          std::string t_id;
          data->getValue(GENERATOR_ID,&t_id,j);
          if (tag == t_id) {
            g_id = j;
            break;
          }
        }
        if (g_id == -1) continue;

        double rval;
        int ival;
        if (!data->getValue("GENERATOR_TYPE",&ival,g_id)) {
          data->addValue("GENERATOR_TYPE", uc_data[i].type, g_id);
        } else {
          data->setValue("GENERATOR_TYPE", uc_data[i].type, g_id);
        }

        if (!data->getValue("GENERATOR_INIT_LEVEL",&rval,g_id)) {
          data->addValue("GENERATOR_INIT_LEVEL", uc_data[i].init_level, g_id);
        } else {
          data->setValue("GENERATOR_INIT_LEVEL", uc_data[i].init_level, g_id);
        }

        if (!data->getValue("GENERATOR_MIN_GEN",&rval,g_id)) {
          data->addValue("GENERATOR_MIN_GEN", uc_data[i].min_gen, g_id);
        } else {
          data->setValue("GENERATOR_MIN_GEN", uc_data[i].min_gen, g_id);
        }

        if (!data->getValue("GENERATOR_MAX_GEN",&rval,g_id)) {
          data->addValue("GENERATOR_MAX_GEN", uc_data[i].max_gen, g_id);
        } else {
          data->setValue("GENERATOR_MAX_GEN", uc_data[i].max_gen, g_id);
        }

        if (!data->getValue("GENERATOR_MAX_OP_GEN",&rval,g_id)) {
          data->addValue("GENERATOR_MAX_OP_GEN", uc_data[i].max_gen, g_id);
        } else {
          data->setValue("GENERATOR_MAX_OP_GEN", uc_data[i].max_gen, g_id);
        }
        if (!data->getValue("GENERATOR_MIN_UP",&rval,g_id)) {
          data->addValue("GENERATOR_MIN_UP", uc_data[i].min_up, g_id);
        } else {
          data->setValue("GENERATOR_MIN_UP", uc_data[i].min_up, g_id);
        }

        if (!data->getValue("GENERATOR_MIN_DOWN",&rval,g_id)) {
          data->addValue("GENERATOR_MIN_DOWN", uc_data[i].min_down, g_id);
        } else {
          data->setValue("GENERATOR_MIN_DOWN", uc_data[i].min_down, g_id);
        }

        if (!data->getValue("GENERATOR_RAMP_UP",&rval,g_id)) {
          data->addValue("GENERATOR_RAMP_UP", uc_data[i].ramp_up, g_id);
        } else {
          data->setValue("GENERATOR_RAMP_UP", uc_data[i].ramp_up, g_id);
        }

        if (!data->getValue("GENERATOR_RAMP_DOWN",&rval,g_id)) {
          data->addValue("GENERATOR_RAMP_DOWN", uc_data[i].ramp_down, g_id);
        } else {
          data->setValue("GENERATOR_RAMP_DOWN", uc_data[i].ramp_down, g_id);
        }

        if (!data->getValue("GENERATOR_START_UP",&rval,g_id)) {
          data->addValue("GENERATOR_START_UP", uc_data[i].start_up, g_id);
        } else {
          data->setValue("GENERATOR_START_UP", uc_data[i].start_up, g_id);
        }

        if (!data->getValue("GENERATOR_CONST_COST",&rval,g_id)) {
          data->addValue("GENERATOR_CONST_COST", uc_data[i].const_cost, g_id);
        } else {
          data->setValue("GENERATOR_CONST_COST", uc_data[i].const_cost, g_id);
        }
        if (!data->getValue("GENERATOR_LIN_COST",&rval,g_id)) {
          data->addValue("GENERATOR_LIN_COST", uc_data[i].lin_cost, g_id);
        } else {
          data->setValue("GENERATOR_LIN_COST", uc_data[i].lin_cost, g_id);
        }
        if (!data->getValue("GENERATOR_CO_2_COST",&rval,g_id)) {
          data->addValue("GENERATOR_CO_2_COST", uc_data[i].co_2_cost, g_id);
        } else {
          data->setValue("GENERATOR_CO_2_COST", uc_data[i].co_2_cost, g_id);
        }

        if (!data->getValue("GENERATOR_INIT_PRD",&rval,g_id)) {
          data->addValue("GENERATOR_INIT_PRD", uc_data[i].init_prd, g_id);
        } else {
          data->setValue("GENERATOR_INIT_PRD", uc_data[i].init_prd, g_id);
        }

        if (!data->getValue("GENERATOR_START_CAP",&rval,g_id)) {
          data->addValue("GENERATOR_START_CAP", uc_data[i].start_cap, g_id);
        } else {
          data->setValue("GENERATOR_START_CAP", uc_data[i].start_cap, g_id);
        }

        if (!data->getValue("GENERATOR_SHUT_CAP",&rval,g_id)) {
          data->addValue("GENERATOR_SHUT_CAP", uc_data[i].shut_cap, g_id);
        } else {
          data->setValue("GENERATOR_SHUT_CAP", uc_data[i].shut_cap, g_id);
        }
      }
    }

    // Utility function to check if device is on a generator
    bool onGenerator(std::string &device) {
      bool ret = false;
      if (device == "GENCLS" || device == "GENSAL" || device == "GENROU" ||
          device == "GDFORM" || device == "PLBI" ||
          device == "REGCA1" || device == "REECA1" || device == "REPCA1" ||
	  device == "REPCTA1" || device == "REGCB1" || device == "REGCC1" ||
          device == "WSIEG1" || device == "EXDC1"   || device == "EXDC2" ||
	  device == "IEEET1" ||
	  device == "SEXS"   || device == "GAST"    || device == "HYGOV" ||
          device == "ESST1A" || device == "ESST4B" || device == "GGOV1" ||
          device == "WSHYGP" || device == "TGOV1" || device == "PSSSIM" ||
          device == "WTDTA1" || device == "WTARA1" || device == "WTPTA1" ||
          device == "WTTQA1") {
        ret = true;
      }
      return ret;
    }

    // Utility function to check if device is on a bus
    bool onBus(std::string &device) {
      bool ret = false;
      if (device == "LVSHBL" || device == "FRQTPAT") {
        ret = true;
      }
      return ret;
    }

    // Utility function to check if device is on a branch
    bool onBranch(std::string &device) {
      bool ret = false;
      if (device == "DISTR1") {
        ret = true;
      }
      return ret;
    }

    // Utility function to check if parameters describe a load
    bool onLoad(std::string &device) {
      bool ret = false;
      if (device == "CIM6BL" || device == "USRLOD" ||
          device == "IEELBL") {
        ret = true;
      }
      return ret;
    }


    // Extract extension from file name and convert it to lower case
    std::string getExtension(const std::string file)
    {
      std::string ret;
      std::string line = file;
      int ntok1 = line.find('.',0);
      if (ntok1 == std::string::npos) return ret;
      int nsav = ntok1;
      while(ntok1 != std::string::npos) {
        ntok1 = line.find('.',ntok1+1);
        if (ntok1 != std::string::npos) nsav=ntok1;
      }
      ntok1 = nsav;
      ntok1++;
      int ntok2 = line.find(' ',ntok1);
      if (ntok2 == std::string::npos)
        ntok2 = line.size();
      // get extension
      ret = line.substr(ntok1,ntok2-ntok1);
      // convert all characters to lower case 
      int size = ret.size();
      int i;
      for (i=0; i<size; i++) {
        if (isalpha(ret[i])) {
          ret[i] = tolower(ret[i]);
        }
      }
      return ret;
    }

    void find_ds_par(std::ifstream & input)
    {
      std::string          line;
      gridpack::component::DataCollection *data;
      while(std::getline(input,line)) {
        // Check to see if line is blank
        int idx = line.find_first_not_of(' ');
        if (idx == std::string::npos) continue;

        std::string record = line;
        idx = line.find('/');
        while (idx == std::string::npos) {
          std::getline(input,line);
          idx = line.find('/');
          record.append(line);
        }
        idx = record.find('/');
        if (idx != std::string::npos) record.erase(idx,record.length()-idx);
        std::vector<std::string>  split_line;
        split_line = splitPSSELine(record);

        std::string sval;
        // MODEL TYPE              "MODEL"                  string
        gridpack::utility::StringUtils util;
        sval = util.trimQuotes(split_line[1]);
        util.toUpper(sval);

        if (onGenerator(sval)) {
          // GENERATOR_BUSNUMBER               "I"                   integer
          int l_idx, o_idx;
          o_idx = atoi(split_line[0].c_str());
#ifdef OLD_MAP
          std::map<int, int>::iterator it;
#else
          boost::unordered_map<int, int>::iterator it;
#endif
          it = p_busMap->find(o_idx);
          if (it != p_busMap->end()) {
            l_idx = it->second;
          } else {
            continue;
          }
          data = dynamic_cast<gridpack::component::DataCollection*>
            (p_network->getBusData(l_idx).get());

          // Find out how many generators are already on bus
          int ngen = 0;
          data->getValue(GENERATOR_NUMBER, &ngen);
          // Identify index of generator to which this data applies
          int g_id = -1;
          if (ngen > 0) {
            // Clean up 2 character tag for generator ID
            std::string tag = util.clean2Char(split_line[2]);
            int i;
            for (i=0; i<ngen; i++) {
              std::string t_id;
              data->getValue(GENERATOR_ID,&t_id,i);
              if (tag == t_id) {
                g_id = i;
                break;
              }
            }
          }

          double rval;
          int ival;
          bool bval;

          if (g_id > -1) {
            if (sval == "GENCLS") {
              GenclsParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "GENSAL") {
              GensalParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "GENROU") {
              GenrouParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "GDFORM") {
              GdformParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "PLBI") {
              GenrouParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "REGCA1") {
              Regca1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "REGCB1") {
              Regcb1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "REGCC1") {
              Regcc1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "REECA1") {
              Reeca1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "REPCA1") {
              Repca1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "REPCTA1") {
              Repca1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "WSIEG1") {
              Wsieg1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "EXDC1" || sval == "EXDC2") {
              Exdc1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "IEEET1") {
              Ieeet1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "SEXS") {
              SexsParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "ESST1A") {
              Esst1aParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "ESST4A") {
              Esst4bParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "GGOV1") {
              Ggov1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "TGOV1") {
              Tgov1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "GAST") {
              GastParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
	    } else if (sval == "HYGOV") {
              HygovParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "WSHYGP") {
              WshygpParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "PSSSIM") {
              PsssimParser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "WTDTA1") {
              Wtdta1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "WTARA1") {
              Wtara1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "WTPTA1") {
              Wtpta1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            } else if (sval == "WTTQA1") {
              Wttqa1Parser<gen_params> parser;
              parser.parse(split_line, data, g_id);
            }
          }
        } else if (onBus(sval)) {
          int l_idx, o_idx;
          if (sval == "LVSHBL") {
            o_idx = atoi(split_line[0].c_str());
          } else if (sval == "FRQTPAT") {
            o_idx = atoi(split_line[3].c_str());
          }
#ifdef OLD_MAP
          std::map<int, int>::iterator it;
#else
          boost::unordered_map<int, int>::iterator it;
#endif
          it = p_busMap->find(o_idx);
          if (it != p_busMap->end()) {
            l_idx = it->second;
          } else {
            continue;
          }
          data = dynamic_cast<gridpack::component::DataCollection*>
            (p_network->getBusData(l_idx).get());
          if (sval == "LVSHBL") {
            LvshblParser<gen_params> parser;
            parser.parse(split_line, data);
          } else if (sval == "FRQTPAT") {
            FrqtpatParser<gen_params> parser;
            parser.parse(split_line, data);
          }
        } else if (onLoad(sval)) {
          // Load bus number
          int l_idx, o_idx;
          o_idx = atoi(split_line[0].c_str());
#ifdef OLD_MAP
          std::map<int, int>::iterator it;
#else
          boost::unordered_map<int, int>::iterator it;
#endif
          it = p_busMap->find(o_idx);
          if (it != p_busMap->end()) {
            l_idx = it->second;
          } else {
            continue;
          }
          data = dynamic_cast<gridpack::component::DataCollection*>
            (p_network->getBusData(l_idx).get());

          // Find out how many loads are already on bus
          int nload = 0;
          data->getValue(LOAD_NUMBER, &nload);
          // Identify index of load to which this data applies
          int l_id = -1;
          if (nload > 0) {
            // Clean up 2 character tag for load ID
            std::string tag = util.clean2Char(split_line[2]);
            int i;
            for (i=0; i<nload; i++) {
              std::string t_id;
              data->getValue(LOAD_ID,&t_id,i);
              if (tag == t_id) {
                l_id = i;
                break;
              }
            }
          }
          if (sval == "CIM6BL") {
            Cim6blParser<load_params> parser;
            parser.parse(split_line, data, l_id);
          } else if (sval == "IEELBL") {
            IeelblParser<load_params> parser;
            parser.parse(split_line, data, l_id);
          } else if (sval == "USRLOD") {
            std::string sdev;
            sdev = util.trimQuotes(split_line[3]);
            if (sdev == "ACMTBLU1") {
              Acmtblu1Parser<load_params> parser;
              parser.parse(split_line, data, l_id);
            } else if (sdev == "CMLDBLU1") {
              Cmldblu1Parser<load_params> parser;
              parser.parse(split_line, data, l_id);
            }
          }
        } else if (onBranch(sval)) {
          int l_idx, from_idx, to_idx;
          from_idx = atoi(split_line[0].c_str());
          to_idx = atoi(split_line[2].c_str());
          std::map<std::pair<int, int>, int>::iterator it;
          it = p_branchMap->find(std::pair<int,int>(from_idx,to_idx));
          if (it != p_branchMap->end()) {
            l_idx = it->second;
          } else {
            continue;
          }
          if (sval == "DISTR1") {
            Distr1Parser<gen_params> parser;
            parser.parse(split_line, data);
          }
        }
      }
    }

    // Parse file to construct lists of structs representing different devices.
    void find_ds_vector(std::ifstream & input, std::vector<gen_params> *gen_vector,
        std::vector<bus_relay_params> *bus_relay_vector,
        std::vector<branch_relay_params> *branch_relay_vector,
        std::vector<load_params> *load_vector)
    {
      std::string          line;
      gen_vector->clear();
      while(std::getline(input,line)) {
        // Check to see if line is blank
        int idx = line.find_first_not_of(' ');
	int idx2 = line.find_first_not_of('\r'); // Some systems use \r\n for line ends.
        if (idx == std::string::npos || idx2 == std::string::npos) continue;
        // Check to see if line is a comment
        if (line[idx] == '/') {
          if (line.length() > idx+2 && line[idx+1] == '/') {
            continue;
          }
        }

        std::string record = line;
        idx = line.find('/');
        while (idx == std::string::npos) {
          std::getline(input,line);
          idx = line.find('/');
          record.append(line);
        }
        idx = record.find('/');
        if (idx != std::string::npos) record.erase(idx,record.length()-idx);
        std::vector<std::string>  split_line;
        split_line = splitPSSELine(record);
        std::string sval;
        gridpack::utility::StringUtils util;
        sval = util.trimQuotes(split_line[1]);
        util.toUpper(sval);

        if (onGenerator(sval)) {
          gen_params data;

          // GENERATOR_BUSNUMBER               "I"                   integer
          int o_idx;
          o_idx = atoi(split_line[0].c_str());
          data.bus_id = o_idx;

          // Clean up 2 character tag for generator ID
          std::string tag = util.clean2Char(split_line[2]);
	  

	  
          strcpy(data.gen_id, tag.c_str());

          double rval;
          int ival;


          // GENERATOR_MODEL              "MODEL"                  integer
          strcpy(data.model, sval.c_str());

          if (sval == "GENCLS") {
            GenclsParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "GENSAL") {
            GensalParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "GENROU") {
            GenrouParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "GDFORM") {
            GdformParser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "PLBI") {
            PlbiParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "REGCA1") {
            Regca1Parser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "REGCB1") {
            Regcb1Parser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "REGCC1") {
            Regcc1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "REECA1") {
            Reeca1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "REPCA1") {
            Repca1Parser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "REPCTA1") {
            Repca1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "WSIEG1") {
            Wsieg1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "EXDC1" || sval == "EXDC2") {
            Exdc1Parser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "IEEET1") {
            Ieeet1Parser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "SEXS") {
            SexsParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "ESST1A") {
            Esst1aParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "ESST4B") {
            Esst4bParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "GGOV1") {
            Ggov1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "TGOV1") {
            Tgov1Parser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "GAST") {
            GastParser<gen_params> parser;
            parser.store(split_line,data);
	  } else if (sval == "HYGOV") {
            HygovParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "WSHYGP") {
            WshygpParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "PSSSIM") {
            PsssimParser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "WTDTA1") {
            Wtdta1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "WTARA1") {
            Wtara1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "WTPTA1") {
            Wtpta1Parser<gen_params> parser;
            parser.store(split_line,data);
          } else if (sval == "WTTQA1") {
            Wttqa1Parser<gen_params> parser;
            parser.store(split_line,data);
          }
          gen_vector->push_back(data);
        } else if (onBus(sval)) {

          // RELAY_BUSNUMBER               "I"                   integer
          int o_idx;
          if (sval == "LVSHBL") {
            bus_relay_params data;
            o_idx = atoi(split_line[0].c_str());
            data.bus_id = o_idx;
            LvshblParser<bus_relay_params> parser;
            parser.store(split_line,data);
            bus_relay_vector->push_back(data);
          } else if (sval == "FRQTPAT") {
            bus_relay_params data;
            o_idx = atoi(split_line[3].c_str());
            data.bus_id = o_idx;
            FrqtpatParser<bus_relay_params> parser;
            parser.store(split_line,data);
            bus_relay_vector->push_back(data);
          }
        } else if (onLoad(sval)) {
          // ID of bus that owns load
          load_params data;
          int o_idx = atoi(split_line[0].c_str());
          data.bus_id = o_idx;

          // Clean up 2 character tag for load ID
          std::string tag = util.clean2Char(split_line[2]);
          strcpy(data.id, tag.c_str());
          if (sval == "CIM6BL") {
            Cim6blParser<load_params> parser;
            parser.store(split_line,data);
          } else if (sval == "IEELBL") {
            IeelblParser<load_params> parser;
            parser.store(split_line,data);
          } else if (sval == "USRLOD") {
            std::string sdev;
            sdev = util.trimQuotes(split_line[3]);
            if (sdev == "ACMTBLU1") {
              Acmtblu1Parser<load_params> parser;
              parser.store(split_line,data);
            } else if (sdev == "CMLDBLU1") {
              Cmldblu1Parser<load_params> parser;
              parser.store(split_line,data);
            }
          }
          load_vector->push_back(data);
        } else if (onBranch(sval)) {
          branch_relay_params data;

          int from_idx, to_idx;
          if (sval == "DISTR1") {
            from_idx = atoi(split_line[0].c_str());
            to_idx = atoi(split_line[3].c_str());
            data.from_bus = from_idx;
            data.to_bus = to_idx;
            Distr1Parser<branch_relay_params> parser;
            parser.store(split_line,data);
          }
          branch_relay_vector->push_back(data);
        }
      }
    }

    void find_uc_vector(std::ifstream & input, std::vector<uc_params> *uc_vector)
    {
      std::string          line;
      uc_vector->clear();
      // Ignore first line containing header information
      std::getline(input,line);
      while(std::getline(input,line)) {
        std::vector<std::string>  split_line;
        split_line = splitPSSELine(line);

        uc_params data;

        int nstr = split_line.size();
        if (nstr > 1) {
          data.type = atoi(split_line[1].c_str());
        }
        if (nstr > 2) {
          data.init_level = atof(split_line[2].c_str());
        }
        if (nstr > 3) {
          data.min_gen = atof(split_line[3].c_str());
        }
        if (nstr > 4) {
          data.max_gen = atof(split_line[4].c_str());
        }
        if (nstr > 5) {
          data.max_oper = atof(split_line[5].c_str());
        }
        if (nstr > 6) {
          data.min_up = atof(split_line[6].c_str());
        }
        if (nstr > 7) {
          data.min_down = atof(split_line[7].c_str());
        }
        if (nstr > 8) {
          data.ramp_up = atof(split_line[8].c_str());
        }
        if (nstr > 9) {
          data.ramp_down = atof(split_line[9].c_str());
        }
        if (nstr > 10) {
          data.start_up = atof(split_line[10].c_str());
        }
        if (nstr > 11) {
          data.const_cost = atof(split_line[11].c_str());
        }
        if (nstr > 12) {
          data.lin_cost = atof(split_line[12].c_str());
        }
        if (nstr > 13) {
          data.co_2_cost = atof(split_line[13].c_str());
        }
        if (nstr > 14) {
          data.init_prd = atof(split_line[14].c_str());
        }
        if (nstr > 15) {
          data.start_cap = atof(split_line[15].c_str());
        }
        if (nstr > 16) {
          data.shut_cap = atof(split_line[16].c_str());
        }
        if (nstr > 17) {
          data.bus_id = atoi(split_line[17].c_str());
        }
        if (nstr > 18) {
          // Clean up 2 character tag for generator ID
          gridpack::utility::StringUtils util;
          std::string tag = util.clean2Char(split_line[18]);
          strcpy(data.gen_id, tag.c_str());
        }
        uc_vector->push_back(data);
      }
    }

    /** Store pointer to bus and branch maps
     * @param busMap pointer to map between PTI and local indices
     * @param branchMap pointer to map between PTI bus pairs and local branch
     *        indices
     */
    void setMaps(std::map<int,int> *busMap,
                 std::map<std::pair<int, int>, int> *branchMap)
    {
      p_busMap = busMap;
      p_branchMap = branchMap;
    }

    /**
     * Remove comment from string (all text after a single '/' character)
     * Check to see if '/' character occurs in a text string (delimited by
     * either '' or "")
     * @param string line of text to be cleaned
     */
    void cleanComment(std::string &string)
    {
      int idx = string.find_first_of('/',0);
      if (idx != std::string::npos) {
        // check to see if '/' character is between two quotes
        bool squote = true;
        int d1 = string.find_first_of('\'',0);
        if (d1 == std::string::npos) {
          d1 = string.find_first_of('\"',0);
          if (d1 != std::string::npos) squote = false;
        }
        int d2 = d1;
        if (d1 != std::string::npos) {
          if (squote) {
            if (string.length() > d1+1) d2 = string.find_first_of('\'',d1+1);
          } else {
            if (string.length() > d1+1) d2 = string.find_first_of('\"',d1+1);
          }
        }
        // if '/' is between two quotes, return
        if (d1 != std::string::npos && d2 != std::string::npos
            && d1 < idx && idx < d2) return;
        int len = string.length()-idx;
        string.erase(idx,len);
      }
    }


    /**
     * Check to see if string is blank
     * @return true if no non-blank characters are found
     */
    bool isBlank(std::string string)
    {
      int idx = string.find_first_not_of(' ',0);
      if (idx != std::string::npos) return false;
      return true;
    } 
    /* ************************************************************************
     **************************************************************************
     ***** OBJECT DATA
     **************************************************************************
     *********************************************************************** */
  private:
    boost::shared_ptr<_network> p_network;

    gridpack::utility::CoarseTimer *p_timer;

    // Map of PTI indices to index in p_busData
    std::map<int,int> *p_busMap;
    // Map of PTI index pair to index in p_branchData
    std::map<std::pair<int, int>, int> *p_branchMap;

    // String utility object for splitting lines in PSS/E files
    gridpack::utility::StringUtils p_util;

    /**
     * Data collection object associated with network as a whole
     */
    boost::shared_ptr<gridpack::component::DataCollection> p_network_data;
}; /* end of PTI base parser */

} /* namespace parser */
} /* namespace gridpack */

#endif /* BASEPTIPARSER_HPP_ */
